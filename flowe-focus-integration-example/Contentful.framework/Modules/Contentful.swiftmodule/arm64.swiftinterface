// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.2 (swiftlang-1103.0.32.1 clang-1103.0.32.29)
// swift-module-flags: -target arm64-apple-ios8.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Contentful
@_exported import Contentful
import CoreGraphics
import Foundation
import Swift
import UIKit
public struct ArrayResponseError : Swift.Decodable {
  public struct Sys : Swift.Decodable {
    public let id: Swift.String
    public let type: Swift.String
    public init(from decoder: Swift.Decoder) throws
  }
  public let details: Contentful.Link.Sys
  public let sys: Contentful.ArrayResponseError.Sys
  public init(from decoder: Swift.Decoder) throws
}
public struct HomogeneousArrayResponse<ItemType> where ItemType : Contentful.EndpointAccessible, ItemType : Swift.Decodable {
  public let items: [ItemType]
  public let limit: Swift.UInt
  public let skip: Swift.UInt
  public let total: Swift.UInt
  public let errors: [Contentful.ArrayResponseError]?
}
@available(*, deprecated, message: "Use HomogeneousArrayResponse instead")
public typealias ArrayResponse = Contentful.HomogeneousArrayResponse
extension HomogeneousArrayResponse : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
public struct HeterogeneousArrayResponse {
  public let items: [Contentful.EntryDecodable]
  public let limit: Swift.UInt
  public let skip: Swift.UInt
  public let total: Swift.UInt
  public let errors: [Contentful.ArrayResponseError]?
}
@available(*, deprecated, message: "Use HeterogeneousArrayResponse instead")
public typealias MixedArrayResponse = Contentful.HeterogeneousArrayResponse
extension HeterogeneousArrayResponse : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
public protocol AssetProtocol : Contentful.FlatResource {
  var urlString: Swift.String? { get }
}
public protocol AssetDecodable : Contentful.AssetProtocol, Swift.Decodable {
}
@_inheritsConvenienceInitializers public class Asset : Contentful.LocalizableResource, Contentful.AssetDecodable {
  public enum Fields : Swift.String, Swift.CodingKey {
    case title, description, file
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
    public init?(stringValue: Swift.String)
    public var intValue: Swift.Int? {
      get
    }
    public init?(intValue: Swift.Int)
  }
  public var url: Foundation.URL? {
    get
  }
  public var urlString: Swift.String? {
    get
  }
  public var title: Swift.String? {
    get
  }
  public var description: Swift.String? {
    get
  }
  public var file: Contentful.Asset.FileMetadata? {
    get
  }
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
}
extension AssetProtocol {
  public func url(with imageOptions: [Contentful.ImageOption] = []) throws -> Foundation.URL
}
extension Asset {
  public struct FileMetadata : Swift.Decodable {
    public let fileName: Swift.String
    public let contentType: Swift.String
    public let details: Contentful.Asset.FileMetadata.Details?
    public let url: Foundation.URL?
    public struct Details : Swift.Decodable {
      public let size: Swift.Int
      public let imageInfo: Contentful.Asset.FileMetadata.Details.ImageInfo?
      public struct ImageInfo : Swift.Decodable {
        public let width: Swift.Double
        public let height: Swift.Double
        public init(from decoder: Swift.Decoder) throws
      }
      public init(from decoder: Swift.Decoder) throws
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
extension Asset : Contentful.EndpointAccessible {
  public static let endpoint: Contentful.Endpoint
}
extension Asset : Contentful.ResourceQueryable {
  public typealias QueryType = Contentful.AssetQuery
}
extension Client {
  @discardableResult
  public func fetchImage(for asset: Contentful.Asset, with imageOptions: [Contentful.ImageOption] = [], then completion: @escaping Contentful.ResultsHandler<UIKit.UIImage>) -> Foundation.URLSessionDataTask?
}
public typealias ResultsHandler<T> = (Contentful.Result<T>) -> Swift.Void
open class Client {
  final public let clientConfiguration: Contentful.ClientConfiguration
  final public let spaceId: Swift.String
  final public let environmentId: Swift.String
  public var locales: [Contentful.Locale]?
  public var localizationContext: Contentful.LocalizationContext! {
    get
  }
  final public let host: Swift.String
  public var jsonDecoder: Foundation.JSONDecoder {
    get
  }
  public var persistenceIntegration: Contentful.PersistenceIntegration? {
    get
    set
  }
  public init(spaceId: Swift.String, environmentId: Swift.String = "master", accessToken: Swift.String, host: Swift.String = Host.delivery, clientConfiguration: Contentful.ClientConfiguration = .default, sessionConfiguration: Foundation.URLSessionConfiguration = .default, persistenceIntegration: Contentful.PersistenceIntegration? = nil, contentTypeClasses: [Contentful.EntryDecodable.Type]? = nil)
  @objc deinit
  public func url(endpoint: Contentful.Endpoint, parameters: [Swift.String : Swift.String]? = nil) -> Foundation.URL
  public func fetch<DecodableType>(url: Foundation.URL, then completion: @escaping Contentful.ResultsHandler<DecodableType>) -> Foundation.URLSessionDataTask where DecodableType : Swift.Decodable
  public func fetch(url: Foundation.URL, then completion: @escaping Contentful.ResultsHandler<Foundation.Data>) -> Foundation.URLSessionDataTask
}
extension Client {
  @discardableResult
  public func fetchLocales(then completion: @escaping Contentful.ResultsHandler<Contentful.HomogeneousArrayResponse<Contentful.Locale>>) -> Foundation.URLSessionDataTask
}
extension Client {
  @discardableResult
  public func fetchSpace(then completion: @escaping Contentful.ResultsHandler<Contentful.Space>) -> Foundation.URLSessionDataTask?
}
extension Client {
  @discardableResult
  public func fetchData(for asset: Contentful.AssetProtocol, with imageOptions: [Contentful.ImageOption] = [], then completion: @escaping Contentful.ResultsHandler<Foundation.Data>) -> Foundation.URLSessionDataTask?
}
extension Client {
  @discardableResult
  public func fetch<ResourceType>(_ resourceType: ResourceType.Type, id: Swift.String, include includesLevel: Swift.UInt? = nil, then completion: @escaping Contentful.ResultsHandler<ResourceType>) -> Foundation.URLSessionDataTask where ResourceType : Contentful.EndpointAccessible, ResourceType : Swift.Decodable
  @discardableResult
  public func fetchArray<ResourceType, QueryType>(of resourceType: ResourceType.Type, matching query: QueryType? = nil, then completion: @escaping Contentful.ResultsHandler<Contentful.HomogeneousArrayResponse<ResourceType>>) -> Foundation.URLSessionDataTask where ResourceType : Contentful.EndpointAccessible, ResourceType : Contentful.ResourceQueryable, ResourceType : Swift.Decodable, QueryType == ResourceType.QueryType
  @discardableResult
  public func fetchArray<EntryType>(of entryType: EntryType.Type, matching query: Contentful.QueryOn<EntryType> = QueryOn<EntryType>(), then completion: @escaping Contentful.ResultsHandler<Contentful.HomogeneousArrayResponse<EntryType>>) -> Foundation.URLSessionDataTask where EntryType : Contentful.EntryDecodable, EntryType : Contentful.FieldKeysQueryable
  @discardableResult
  public func fetchArray(matching query: Contentful.Query? = nil, then completion: @escaping Contentful.ResultsHandler<Contentful.HeterogeneousArrayResponse>) -> Foundation.URLSessionDataTask
}
extension Client {
  @discardableResult
  public func sync(for syncSpace: Contentful.SyncSpace = SyncSpace(), syncableTypes: Contentful.SyncSpace.SyncableTypes = .all, then completion: @escaping Contentful.ResultsHandler<Contentful.SyncSpace>) -> Foundation.URLSessionDataTask?
}
public enum Host {
  public static let delivery: Swift.String
  public static let preview: Swift.String
}
public protocol Integration {
  var name: Swift.String { get }
  var version: Swift.String { get }
}
public struct ClientConfiguration {
  public static let `default`: Contentful.ClientConfiguration
  public init()
  public var secure: Swift.Bool
  public var dateDecodingStrategy: Foundation.JSONDecoder.DateDecodingStrategy?
  public var timeZone: Foundation.TimeZone?
}
public protocol CustomLogger {
  func log(message: Swift.String)
}
public enum ContentfulLogger {
  public static var logType: Contentful.ContentfulLogger.LogType
  public static var logLevel: Contentful.ContentfulLogger.LogLevel
  public enum LogLevel : Swift.Int {
    case none
    case error
    case info
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum LogType {
    case print
    case nsLog
    case custom(Contentful.CustomLogger)
  }
}
public class ContentType : Contentful.Resource, Contentful.FlatResource, Swift.Decodable, Contentful.ResourceQueryable {
  public typealias QueryType = Contentful.ContentTypeQuery
  final public let sys: Contentful.Sys
  final public let fields: [Contentful.Field]
  final public let name: Swift.String
  final public let description: Swift.String?
  public var type: Swift.String {
    get
  }
  required public init(from decoder: Swift.Decoder) throws
  public enum QueryableCodingKey : Swift.String, Swift.CodingKey {
    case name, description
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
    public init?(stringValue: Swift.String)
    public var intValue: Swift.Int? {
      get
    }
    public init?(intValue: Swift.Int)
  }
  @objc deinit
}
extension ContentType : Contentful.EndpointAccessible {
  public static let endpoint: Contentful.Endpoint
}
extension Date {
  public enum Error : Swift.String, Swift.Error {
    case unsupportedDateFormat
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public static func iso8601Formatter(timeZone: Foundation.TimeZone? = nil) -> Foundation.DateFormatter
  public static func variableISO8601Strategy(_ decoder: Swift.Decoder) throws -> Foundation.Date
  public var iso8601String: Swift.String {
    get
  }
}
extension String {
  public var iso8601StringDate: Foundation.Date? {
    get
  }
}
extension Decoder {
  public var canResolveLinks: Swift.Bool {
    get
  }
  public var timeZone: Foundation.TimeZone? {
    get
  }
  public var localizationContext: Contentful.LocalizationContext {
    get
  }
  public func sys() throws -> Contentful.Sys
  public func contentfulFieldsContainer<NestedKey>(keyedBy keyType: NestedKey.Type) throws -> Swift.KeyedDecodingContainer<NestedKey> where NestedKey : Swift.CodingKey
}
extension JSONDecoder {
  public static func withoutLocalizationContext() -> Foundation.JSONDecoder
  public func update(with localizationContext: Contentful.LocalizationContext)
}
extension KeyedDecodingContainer {
  public func resolveLink(forKey key: Swift.KeyedDecodingContainer<K>.Key, decoder: Swift.Decoder, callback: @escaping (Swift.AnyObject) -> Swift.Void) throws
  public func resolveLinksArray(forKey key: Swift.KeyedDecodingContainer<K>.Key, decoder: Swift.Decoder, callback: @escaping (Swift.AnyObject) -> Swift.Void) throws
}
public enum Endpoint : Swift.String {
  case spaces
  case contentTypes
  case entries
  case assets
  case locales
  case sync
  public var pathComponent: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public protocol EntryDecodable : Contentful.EndpointAccessible, Contentful.FlatResource, Swift.Decodable {
  static var contentTypeId: Contentful.ContentTypeId { get }
}
extension EndpointAccessible where Self : Contentful.EntryDecodable {
  public static var endpoint: Contentful.Endpoint {
    get
  }
}
@_inheritsConvenienceInitializers public class Entry : Contentful.LocalizableResource {
  public subscript(key: Swift.String) -> Swift.String? {
    get
  }
  public subscript(key: Swift.String) -> Swift.Int? {
    get
  }
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
}
extension Entry : Contentful.EndpointAccessible {
  public static let endpoint: Contentful.Endpoint
}
extension Entry : Contentful.ResourceQueryable {
  public typealias QueryType = Contentful.Query
}
public enum SDKError : Swift.Error, Swift.CustomDebugStringConvertible {
  case invalidHTTPResponse(response: Foundation.URLResponse?)
  case invalidURL(string: Swift.String)
  case previewAPIDoesNotSupportSync
  case unparseableJSON(data: Foundation.Data?, errorMessage: Swift.String)
  case noResourceFoundFor(id: Swift.String)
  case unableToDecodeImageData
  case localeHandlingError(message: Swift.String)
  public var debugDescription: Swift.String {
    get
  }
}
public enum QueryError : Swift.Error, Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
  case textSearchTooShort
  case invalidOrderProperty
  case invalidSelection(fieldKeyPath: Swift.String)
  case maxSelectionLimitExceeded
}
public class APIError : Swift.Decodable, Swift.Error, Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
  public struct Sys : Swift.Decodable {
    public let id: Swift.String
    public let type: Swift.String
    public init(from decoder: Swift.Decoder) throws
  }
  final public let sys: Contentful.APIError.Sys
  final public let message: Swift.String!
  final public let requestId: Swift.String!
  public var statusCode: Swift.Int!
  final public let details: Contentful.APIError.Details?
  public struct Details : Swift.Decodable {
    public let errors: [Contentful.APIError.Details.Error]
    public struct Error : Swift.Decodable {
      public let name: Swift.String
      public let path: [Swift.String]
      public let details: Swift.String?
      public init(from decoder: Swift.Decoder) throws
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public var id: Swift.String {
    get
  }
  public var type: Swift.String {
    get
  }
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
}
@_inheritsConvenienceInitializers final public class RateLimitError : Contentful.APIError {
  final public var timeBeforeLimitReset: Swift.Int? {
    get
  }
  override final public var debugDescription: Swift.String {
    get
  }
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
}
public typealias FieldName = Swift.String
public enum FieldType : Swift.String, Swift.Decodable {
  case array
  case asset
  case boolean
  case date
  case entry
  case integer
  case link
  case location
  case number
  case object
  case symbol
  case text
  case none
  case richText
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct Field : Swift.Decodable {
  public let id: Swift.String
  public let name: Swift.String
  public let disabled: Swift.Bool
  public let localized: Swift.Bool
  public let required: Swift.Bool
  public let type: Contentful.FieldType
  public let itemType: Contentful.FieldType?
  public init(from decoder: Swift.Decoder) throws
}
extension String {
  public func url(with imageOptions: [Contentful.ImageOption]) throws -> Foundation.URL
}
public enum ImageOption : Swift.Equatable, Swift.Hashable {
  case height(Swift.UInt)
  case width(Swift.UInt)
  case formatAs(Contentful.Format)
  case fit(for: Contentful.Fit)
  case withCornerRadius(Swift.Float)
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public func == (lhs: Contentful.ImageOption, rhs: Contentful.ImageOption) -> Swift.Bool
public enum JPGQuality {
  case unspecified
  case asPercent(Swift.UInt)
  case progressive
}
public enum PngBits {
  case standard
  case eight
  public static func == (a: Contentful.PngBits, b: Contentful.PngBits) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum Format {
  case jpg(withQuality: Contentful.JPGQuality)
  case png(bits: Contentful.PngBits)
  case webp
}
public enum Focus : Swift.String {
  case top
  case bottom
  case left
  case right
  case topLeft
  case topRight
  case bottomLeft
  case bottomRight
  case face
  case faces
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public enum Fit {
  public typealias Color = UIKit.UIColor
  case pad(withBackgroundColor: Contentful.Fit.Color?)
  case crop(focusingOn: Contentful.Focus?)
  case fill(focusingOn: Contentful.Focus?)
  case thumb(focusingOn: Contentful.Focus?)
  case scale
}
public struct ImageOptionError : Swift.Error, Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum Link : Swift.Codable {
  public struct Sys : Swift.Codable {
    public let id: Swift.String
    public let linkType: Swift.String
    public let type: Swift.String
    public init(id: Swift.String, linkType: Swift.String, type: Swift.String)
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
  }
  case asset(Contentful.Asset)
  case entry(Contentful.Entry)
  case entryDecodable(Contentful.EntryDecodable)
  case unresolved(Contentful.Link.Sys)
  public var id: Swift.String {
    get
  }
  public var entry: Contentful.Entry? {
    get
  }
  public var asset: Contentful.Asset? {
    get
  }
  public var entryDecodable: Contentful.EntryDecodable? {
    get
  }
  public var sys: Contentful.Link.Sys {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public typealias LocaleCode = Swift.String
extension Locale : Contentful.EndpointAccessible {
  public static let endpoint: Contentful.Endpoint
}
public class Locale : Contentful.Resource, Contentful.FlatResource, Swift.Decodable {
  final public let sys: Contentful.Sys
  final public let fallbackLocaleCode: Contentful.LocaleCode?
  final public let code: Contentful.LocaleCode
  final public let isDefault: Swift.Bool
  final public let name: Swift.String
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
}
public class LocalizationContext {
  final public let locales: [Contentful.LocaleCode : Contentful.Locale]
  final public let `default`: Contentful.Locale
  public init?(locales: [Contentful.Locale])
  @objc deinit
}
@objc public class Location : ObjectiveC.NSObject, Swift.Decodable, Foundation.NSCoding {
  final public let latitude: Swift.Double
  final public let longitude: Swift.Double
  public init(latitude: Swift.Double, longitude: Swift.Double)
  required public init(from decoder: Swift.Decoder) throws
  @objc required public init?(coder aDecoder: Foundation.NSCoder)
  @objc public func encode(with aCoder: Foundation.NSCoder)
  @objc deinit
  @objc override dynamic public init()
}
public protocol PersistenceIntegration : Contentful.Integration {
  func update(localeCodes: [Contentful.LocaleCode])
  func update(with syncSpace: Contentful.SyncSpace)
  func create(asset: Contentful.Asset)
  func delete(assetWithId: Swift.String)
  func create(entry: Contentful.Entry)
  func delete(entryWithId: Swift.String)
  func update(syncToken: Swift.String)
  func resolveRelationships()
  func save()
}
public enum QueryParameter {
  public static let contentType: Swift.String
  public static let linksToEntry: Swift.String
  public static let linksToAsset: Swift.String
  public static let select: Swift.String
  public static let order: Swift.String
  public static let limit: Swift.String
  public static let skip: Swift.String
  public static let include: Swift.String
  public static let locale: Swift.String
  public static let mimetypeGroup: Swift.String
  public static let fullTextSearch: Swift.String
}
public class Ordering {
  public init(_ propertyKeyPath: Swift.String, inReverse: Swift.Bool = false) throws
  convenience public init(sys: Contentful.Sys.CodingKeys, inReverse: Swift.Bool = false) throws
  @objc deinit
}
public class Ordered<EntryType> : Contentful.Ordering where EntryType : Contentful.FieldKeysQueryable {
  public init(field: EntryType.FieldKeys, inReverse: Swift.Bool = false) throws
  @objc deinit
  override public init(_ propertyKeyPath: Swift.String, inReverse: Swift.Bool = super) throws
}
public protocol QueryableRange {
  var stringValue: Swift.String { get }
}
extension Int : Contentful.QueryableRange {
  public var stringValue: Swift.String {
    get
  }
}
extension String : Contentful.QueryableRange {
  public var stringValue: Swift.String {
    get
  }
}
extension Date : Contentful.QueryableRange {
  public var stringValue: Swift.String {
    get
  }
}
public enum Bounds {
  case box(bottomLeft: Contentful.Location, topRight: Contentful.Location)
  case circle(center: Contentful.Location, radius: Swift.Double)
}
public enum MimetypeGroup : Swift.String {
  case attachment
  case plaintext
  case image
  case audio
  case video
  case richtext
  case presentation
  case spreadsheet
  case pdfdocument
  case archive
  case code
  case markup
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public protocol AbstractQuery : AnyObject {
  init()
  var parameters: [Swift.String : Swift.String] { get set }
}
extension AbstractQuery {
  public static func `where`(sys key: Contentful.Sys.CodingKeys, _ operation: Contentful.Query.Operation) -> Self
  public static func `where`(valueAtKeyPath keyPath: Swift.String, _ operation: Contentful.Query.Operation) -> Self
}
public protocol ChainableQuery : Contentful.AbstractQuery {
}
extension ChainableQuery {
  @discardableResult
  public func `where`(sys key: Contentful.Sys.CodingKeys, _ operation: Contentful.Query.Operation) -> Self
  public static func `where`(field fieldName: Contentful.FieldName, _ operation: Contentful.Query.Operation) -> Self
  @discardableResult
  public func `where`(field fieldName: Contentful.FieldName, _ operation: Contentful.Query.Operation) -> Self
  @discardableResult
  public func `where`(valueAtKeyPath keyPath: Swift.String, _ operation: Contentful.Query.Operation) -> Self
  public static func searching(for text: Swift.String) throws -> Self
  @discardableResult
  public func searching(for text: Swift.String) throws -> Self
  public static func include(_ includesLevel: Swift.UInt) -> Self
  @discardableResult
  public func include(_ includesLevel: Swift.UInt) -> Self
  public static func skip(theFirst numberOfResults: Swift.UInt) -> Self
  @discardableResult
  public func skip(theFirst numberOfResults: Swift.UInt) -> Self
  public static func order(by order: Contentful.Ordering...) -> Self
  @discardableResult
  public func order(by order: Contentful.Ordering...) -> Self
  public static func limit(to numberOfResults: Swift.UInt) -> Self
  @discardableResult
  public func limit(to numberOfResults: Swift.UInt) -> Self
}
public protocol AbstractResourceQuery : Contentful.ChainableQuery {
}
extension AbstractResourceQuery {
  public static func localizeResults(withLocaleCode localeCode: Contentful.LocaleCode) -> Self
  @discardableResult
  public func localizeResults(withLocaleCode localeCode: Contentful.LocaleCode) -> Self
  public static func select(fieldsNamed fieldNames: [Contentful.FieldName]) throws -> Self
  @discardableResult
  public func select(fieldsNamed fieldNames: [Contentful.FieldName]) throws -> Self
}
public protocol EntryQuery : Contentful.AbstractResourceQuery {
}
extension EntryQuery {
  public static func `where`(contentTypeId: Contentful.ContentTypeId) -> Self
  @discardableResult
  public func `where`(contentTypeId: Contentful.ContentTypeId) -> Self
  public static func `where`(linkAtFieldNamed linkingFieldName: Swift.String, onSourceContentTypeWithId sourceContentTypeId: Contentful.ContentTypeId, hasValueAtKeyPath targetKeyPath: Swift.String, withTargetContentTypeId targetContentTypeId: Contentful.ContentTypeId, that operation: Contentful.Query.Operation) -> Self
  @discardableResult
  public func `where`(linkAtFieldNamed linkingFieldName: Swift.String, onSourceContentTypeWithId sourceContentTypeId: Contentful.ContentTypeId, hasValueAtKeyPath targetKeyPath: Swift.String, withTargetContentTypeId targetContentTypeId: Contentful.ContentTypeId, that operation: Contentful.Query.Operation) -> Self
  public static func `where`(linkAtFieldNamed linkingFieldName: Swift.String, onSourceContentTypeWithId sourceContentTypeId: Contentful.ContentTypeId, hasTargetId targetId: Swift.String) -> Self
  @discardableResult
  public func `where`(linkAtFieldNamed linkingFieldName: Swift.String, onSourceContentTypeWithId sourceContentTypeId: Contentful.ContentTypeId, hasTargetId targetId: Swift.String) -> Self
  public static func `where`(linksToEntryWithId entryId: Swift.String) -> Self
  @discardableResult
  public func `where`(linksToEntryWithId entryId: Swift.String) -> Self
  public static func `where`(linksToAssetWithId assetId: Swift.String) -> Self
  @discardableResult
  public func `where`(linksToAssetWithId assetId: Swift.String) -> Self
}
@_hasMissingDesignatedInitializers public class ResourceQuery : Contentful.AbstractResourceQuery {
  public var parameters: [Swift.String : Swift.String]
  required public init()
  @objc deinit
}
extension Query {
  public enum Operation {
    case equals(Swift.String)
    case doesNotEqual(Swift.String)
    case hasAll([Swift.String])
    case includes([Swift.String])
    case excludes([Swift.String])
    case exists(Swift.Bool)
    case matches(Swift.String)
    case isLessThan(Contentful.QueryableRange)
    case isLessThanOrEqualTo(Contentful.QueryableRange)
    case isGreaterThan(Contentful.QueryableRange)
    case isGreaterThanOrEqualTo(Contentful.QueryableRange)
    case isBefore(Contentful.QueryableRange)
    case isAfter(Contentful.QueryableRange)
    case isNear(Contentful.Location)
    case isWithin(Contentful.Bounds)
  }
}
public protocol Resource {
  var sys: Contentful.Sys { get }
}
public protocol FlatResource {
  var id: Swift.String { get }
  var updatedAt: Foundation.Date? { get }
  var createdAt: Foundation.Date? { get }
  var localeCode: Swift.String? { get }
}
extension FlatResource where Self : Contentful.Resource {
  public var id: Swift.String {
    get
  }
  public var type: Swift.String {
    get
  }
  public var updatedAt: Foundation.Date? {
    get
  }
  public var createdAt: Foundation.Date? {
    get
  }
  public var localeCode: Swift.String? {
    get
  }
}
public protocol FieldKeysQueryable {
  associatedtype FieldKeys : Swift.CodingKey
}
public protocol EndpointAccessible {
  static var endpoint: Contentful.Endpoint { get }
}
public protocol ResourceQueryable {
  associatedtype QueryType : Contentful.AbstractQuery
}
public typealias ContentTypeId = Swift.String
@_hasMissingDesignatedInitializers public class DeletedResource : Contentful.Resource, Contentful.FlatResource, Swift.Decodable {
  final public let sys: Contentful.Sys
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
}
public class LocalizableResource : Contentful.Resource, Contentful.FlatResource, Swift.Decodable {
  final public let sys: Contentful.Sys
  public var currentlySelectedLocale: Contentful.Locale
  public var fields: [Contentful.FieldName : Any] {
    get
  }
  @discardableResult
  public func setLocale(withCode code: Contentful.LocaleCode) -> Swift.Bool
  required public init(from decoder: Swift.Decoder) throws
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case sys
    case fields
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
    public init?(stringValue: Swift.String)
    public var intValue: Swift.Int? {
      get
    }
    public init?(intValue: Swift.Int)
  }
  @objc deinit
}
extension LocalizableResource : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension LocalizableResource : Swift.Equatable {
  public static func == (lhs: Contentful.LocalizableResource, rhs: Contentful.LocalizableResource) -> Swift.Bool
}
public protocol ResultType {
  associatedtype Value
  var error: Swift.Error? { get }
  var value: Self.Value? { get }
}
public enum Result<T> : Contentful.ResultType {
  case success(T)
  case error(Swift.Error)
  public init(success value: T)
  public init(error: Swift.Error)
  public var value: T? {
    get
  }
  public var error: Swift.Error? {
    get
  }
  public typealias Value = T
}
public func ?? <T>(result: Contentful.Result<T>, defaultValue: @autoclosure () -> T) -> T
public protocol Node : Swift.Decodable, Swift.Encodable {
  var nodeType: Contentful.NodeType { get }
}
public protocol RecursiveNode : Contentful.Node {
  var content: [Contentful.Node] { get }
  func resolveLinks(against includedEntries: [Contentful.Entry]?, and includedAssets: [Contentful.Asset]?)
}
public class ResourceLinkData : Swift.Codable {
  public var target: Contentful.Link
  final public let title: Swift.String?
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public init(resolvedTarget: Contentful.Link, title: Swift.String? = nil)
  @objc deinit
}
public enum NodeType : Swift.String, Swift.Codable {
  case document
  case paragraph
  case text
  case h1
  case h2
  case h3
  case h4
  case h5
  case h6
  case blockquote
  case horizontalRule
  case orderedList
  case unorderedList
  case listItem
  case embeddedEntryBlock
  case embeddedAssetBlock
  case embeddedEntryInline
  case hyperlink
  case entryHyperlink
  case assetHyperlink
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public class BlockNode : Contentful.RecursiveNode {
  final public let nodeType: Contentful.NodeType
  public var content: [Contentful.Node] {
    get
  }
  required public init(from decoder: Swift.Decoder) throws
  public init(nodeType: Contentful.NodeType, content: [Contentful.Node])
  public func resolveLinks(against includedEntries: [Contentful.Entry]?, and includedAssets: [Contentful.Asset]?)
  public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
public class InlineNode : Contentful.RecursiveNode {
  final public let nodeType: Contentful.NodeType
  public var content: [Contentful.Node] {
    get
  }
  required public init(from decoder: Swift.Decoder) throws
  public init(nodeType: Contentful.NodeType, content: [Contentful.Node])
  public func resolveLinks(against includedEntries: [Contentful.Entry]?, and includedAssets: [Contentful.Asset]?)
  public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
@objc public class RichTextDocument : ObjectiveC.NSObject, Contentful.RecursiveNode, Foundation.NSCoding {
  final public let nodeType: Contentful.NodeType
  public var content: [Contentful.Node] {
    get
  }
  public init(content: [Contentful.Node])
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  @objc public func encode(with aCoder: Foundation.NSCoder)
  @objc required public init?(coder aDecoder: Foundation.NSCoder)
  public func resolveLinks(against includedEntries: [Contentful.Entry]?, and includedAssets: [Contentful.Asset]?)
  @objc deinit
  @objc override dynamic public init()
}
@_inheritsConvenienceInitializers final public class Paragraph : Contentful.BlockNode {
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  override public init(nodeType: Contentful.NodeType, content: [Contentful.Node])
}
@_inheritsConvenienceInitializers final public class UnorderedList : Contentful.BlockNode {
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  override public init(nodeType: Contentful.NodeType, content: [Contentful.Node])
}
@_inheritsConvenienceInitializers final public class OrderedList : Contentful.BlockNode {
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  override public init(nodeType: Contentful.NodeType, content: [Contentful.Node])
}
@_inheritsConvenienceInitializers final public class BlockQuote : Contentful.BlockNode {
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  override public init(nodeType: Contentful.NodeType, content: [Contentful.Node])
}
@_inheritsConvenienceInitializers final public class ListItem : Contentful.BlockNode {
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  override public init(nodeType: Contentful.NodeType, content: [Contentful.Node])
}
@_inheritsConvenienceInitializers final public class HorizontalRule : Contentful.BlockNode {
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  override public init(nodeType: Contentful.NodeType, content: [Contentful.Node])
}
final public class Heading : Contentful.BlockNode {
  final public var level: Swift.UInt!
  public init?(level: Swift.UInt, content: [Contentful.Node])
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
  override public init(nodeType: Contentful.NodeType, content: [Contentful.Node])
}
public class Hyperlink : Contentful.InlineNode {
  final public let data: Contentful.Hyperlink.Data
  public struct Data : Swift.Codable {
    public let uri: Swift.String
    public let title: Swift.String?
    public init(uri: Swift.String, title: Swift.String?)
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
  }
  public init(data: Contentful.Hyperlink.Data, content: [Contentful.Node])
  required public init(from decoder: Swift.Decoder) throws
  override public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
  override public init(nodeType: Contentful.NodeType, content: [Contentful.Node])
}
public class ResourceLinkBlock : Contentful.BlockNode {
  final public let data: Contentful.ResourceLinkData
  public init(resolvedData: Contentful.ResourceLinkData, nodeType: Contentful.NodeType, content: [Contentful.Node])
  required public init(from decoder: Swift.Decoder) throws
  override public func resolveLinks(against includedEntries: [Contentful.Entry]?, and includedAssets: [Contentful.Asset]?)
  override public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
  override public init(nodeType: Contentful.NodeType, content: [Contentful.Node])
}
public class ResourceLinkInline : Contentful.InlineNode {
  final public let data: Contentful.ResourceLinkData
  public init(resolvedData: Contentful.ResourceLinkData, nodeType: Contentful.NodeType, content: [Contentful.Node])
  required public init(from decoder: Swift.Decoder) throws
  override public func resolveLinks(against includedEntries: [Contentful.Entry]?, and includedAssets: [Contentful.Asset]?)
  @objc deinit
  override public init(nodeType: Contentful.NodeType, content: [Contentful.Node])
}
public struct Text : Contentful.Node, Swift.Equatable {
  public let nodeType: Contentful.NodeType
  public let value: Swift.String
  public let marks: [Contentful.Text.Mark]
  public init(value: Swift.String, marks: [Contentful.Text.Mark])
  public struct Mark : Swift.Codable, Swift.Equatable {
    public let type: Contentful.Text.MarkType
    public init(type: Contentful.Text.MarkType)
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
    public static func == (a: Contentful.Text.Mark, b: Contentful.Text.Mark) -> Swift.Bool
  }
  public enum MarkType : Swift.String, Swift.Codable, Swift.Equatable {
    case bold
    case italic
    case underline
    case code
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public static func == (a: Contentful.Text, b: Contentful.Text) -> Swift.Bool
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public class Space : Contentful.Resource, Contentful.FlatResource, Swift.Decodable {
  final public let sys: Contentful.Sys
  final public let locales: [Contentful.Locale]
  final public let name: Swift.String
  public var type: Swift.String {
    get
  }
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
}
extension Space : Contentful.EndpointAccessible {
  public static let endpoint: Contentful.Endpoint
}
final public class SyncSpace : Swift.Decodable {
  final public var parameters: [Swift.String : Swift.String] {
    get
  }
  public enum SyncableTypes {
    case all
    case entries
    case assets
    case entriesOfContentType(withId: Swift.String)
    case allDeletions
    case deletedEntries
    case deletedAssets
    public var parameters: [Swift.String : Swift.String] {
      get
    }
  }
  final public var deletedAssetIds: [Swift.String]
  final public var deletedEntryIds: [Swift.String]
  final public var hasMorePages: Swift.Bool {
    get
  }
  final public var syncToken: Swift.String {
    get
  }
  final public var assets: [Contentful.Asset] {
    get
  }
  final public var entries: [Contentful.Entry] {
    get
  }
  public init(syncToken: Swift.String = "")
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
}
public struct Sys {
  public let id: Swift.String
  public let type: Swift.String
  public let createdAt: Foundation.Date?
  public let updatedAt: Foundation.Date?
  public var locale: Contentful.LocaleCode?
  public var contentTypeId: Swift.String? {
    get
  }
  public let revision: Swift.Int?
  public let contentTypeInfo: Contentful.Link?
}
extension Sys : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case id, type, createdAt, updatedAt, locale, revision, contentType
    public var stringValue: Swift.String {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public init?(stringValue: Swift.String)
    public var intValue: Swift.Int? {
      get
    }
    public init?(intValue: Swift.Int)
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Query : Contentful.ResourceQuery, Contentful.EntryQuery {
  public static var any: Contentful.Query {
    get
  }
  @objc deinit
  required public init()
}
final public class LinkQuery<EntryType> : Contentful.AbstractQuery where EntryType : Contentful.EntryDecodable, EntryType : Contentful.FieldKeysQueryable {
  final public var parameters: [Swift.String : Swift.String]
  public static func `where`(field: EntryType.FieldKeys, _ operation: Contentful.Query.Operation) -> Contentful.LinkQuery<EntryType>
  public init()
  @objc deinit
}
final public class QueryOn<EntryType> : Contentful.EntryQuery where EntryType : Contentful.EntryDecodable, EntryType : Contentful.FieldKeysQueryable {
  final public var parameters: [Swift.String : Swift.String]
  public init()
  public static func `where`(field fieldsKey: EntryType.FieldKeys, _ operation: Contentful.Query.Operation) -> Contentful.QueryOn<EntryType>
  @discardableResult
  final public func `where`(field fieldsKey: EntryType.FieldKeys, _ operation: Contentful.Query.Operation) -> Contentful.QueryOn<EntryType>
  public static func select(fieldsNamed fieldsKeys: [EntryType.FieldKeys]) -> Contentful.QueryOn<EntryType>
  @discardableResult
  final public func select(fieldsNamed fieldsKeys: [EntryType.FieldKeys]) -> Contentful.QueryOn<EntryType>
  public static func `where`<LinkType>(linkAtField fieldsKey: EntryType.FieldKeys, matches linkQuery: Contentful.LinkQuery<LinkType>) -> Contentful.QueryOn<EntryType> where LinkType : Contentful.EntryDecodable, LinkType : Contentful.FieldKeysQueryable
  @discardableResult
  final public func `where`<LinkType>(linkAtField fieldsKey: EntryType.FieldKeys, matches linkQuery: Contentful.LinkQuery<LinkType>) -> Contentful.QueryOn<EntryType> where LinkType : Contentful.EntryDecodable, LinkType : Contentful.FieldKeysQueryable
  public static func `where`(linkAtField fieldsKey: EntryType.FieldKeys, hasTargetId targetId: Swift.String) -> Contentful.QueryOn<EntryType>
  @discardableResult
  final public func `where`(linkAtField fieldsKey: EntryType.FieldKeys, hasTargetId targetId: Swift.String) -> Contentful.QueryOn<EntryType>
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class AssetQuery : Contentful.ResourceQuery {
  public static func `where`(mimetypeGroup: Contentful.MimetypeGroup) -> Contentful.AssetQuery
  @discardableResult
  final public func `where`(mimetypeGroup: Contentful.MimetypeGroup) -> Contentful.AssetQuery
  public static func select(fields fieldsKeys: [Contentful.Asset.Fields]) -> Contentful.AssetQuery
  @discardableResult
  final public func select(fields fieldsKeys: [Contentful.Asset.Fields]) -> Contentful.AssetQuery
  @objc deinit
  required public init()
}
final public class ContentTypeQuery : Contentful.ChainableQuery {
  final public var parameters: [Swift.String : Swift.String]
  required public init()
  public static func `where`(queryableCodingKey: Contentful.ContentType.QueryableCodingKey, _ operation: Contentful.Query.Operation) -> Contentful.ContentTypeQuery
  @discardableResult
  final public func `where`(queryableCodingKey: Contentful.ContentType.QueryableCodingKey, _ operation: Contentful.Query.Operation) -> Contentful.ContentTypeQuery
  @objc deinit
}
public func += <K, V>(left: [K : V], right: [K : V]) -> [K : V] where K : Swift.Hashable
public func + <K, V>(left: [K : V], right: [K : V]) -> [K : V] where K : Swift.Hashable
extension Dictionary where Key : Swift.ExpressibleByStringLiteral {
  public func string(at key: Key) -> Swift.String?
  public func strings(at key: Key) -> [Swift.String]?
  public func int(at key: Key) -> Swift.Int?
  public func int(at key: Key) -> Foundation.Date?
  public func linkedEntry(at key: Key) -> Contentful.Entry?
  public func linkedAsset(at key: Key) -> Contentful.Asset?
  public func linkedEntries(at key: Key) -> [Contentful.Entry]?
  public func linkedAssets(at key: Key) -> [Contentful.Asset]?
  public func bool(at key: Key) -> Swift.Bool?
  public func location(at key: Key) -> Contentful.Location?
}
extension Contentful.Asset.Fields : Swift.Equatable {}
extension Contentful.Asset.Fields : Swift.Hashable {}
extension Contentful.Asset.Fields : Swift.RawRepresentable {}
extension Contentful.ContentfulLogger.LogLevel : Swift.Equatable {}
extension Contentful.ContentfulLogger.LogLevel : Swift.Hashable {}
extension Contentful.ContentfulLogger.LogLevel : Swift.RawRepresentable {}
extension Contentful.ContentType.QueryableCodingKey : Swift.Equatable {}
extension Contentful.ContentType.QueryableCodingKey : Swift.Hashable {}
extension Contentful.ContentType.QueryableCodingKey : Swift.RawRepresentable {}
extension Foundation.Date.Error : Swift.Equatable {}
extension Foundation.Date.Error : Swift.Hashable {}
extension Foundation.Date.Error : Swift.RawRepresentable {}
extension Contentful.Endpoint : Swift.Equatable {}
extension Contentful.Endpoint : Swift.Hashable {}
extension Contentful.Endpoint : Swift.RawRepresentable {}
extension Contentful.FieldType : Swift.Equatable {}
extension Contentful.FieldType : Swift.Hashable {}
extension Contentful.FieldType : Swift.RawRepresentable {}
extension Contentful.PngBits : Swift.Equatable {}
extension Contentful.PngBits : Swift.Hashable {}
extension Contentful.Focus : Swift.Equatable {}
extension Contentful.Focus : Swift.Hashable {}
extension Contentful.Focus : Swift.RawRepresentable {}
extension Contentful.MimetypeGroup : Swift.Equatable {}
extension Contentful.MimetypeGroup : Swift.Hashable {}
extension Contentful.MimetypeGroup : Swift.RawRepresentable {}
extension Contentful.LocalizableResource.CodingKeys : Swift.Equatable {}
extension Contentful.LocalizableResource.CodingKeys : Swift.Hashable {}
extension Contentful.LocalizableResource.CodingKeys : Swift.RawRepresentable {}
extension Contentful.NodeType : Swift.Equatable {}
extension Contentful.NodeType : Swift.Hashable {}
extension Contentful.NodeType : Swift.RawRepresentable {}
extension Contentful.Text.MarkType : Swift.Hashable {}
extension Contentful.Text.MarkType : Swift.RawRepresentable {}
extension Contentful.Sys.CodingKeys : Swift.Equatable {}
extension Contentful.Sys.CodingKeys : Swift.Hashable {}
extension Contentful.Sys.CodingKeys : Swift.RawRepresentable {}
