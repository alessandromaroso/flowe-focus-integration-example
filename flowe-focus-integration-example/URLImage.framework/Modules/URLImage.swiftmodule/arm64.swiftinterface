// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.2 (swiftlang-1103.0.32.1 clang-1103.0.32.29)
// swift-module-flags: -target arm64-apple-ios11.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name URLImage
import Combine
import CoreData
import CoreGraphics
import CoreImage
import Foundation
import ImageIO
import MobileCoreServices
import Swift
import SwiftUI
import UIKit
@_exported import URLImage
import os.log
import os
@available(iOS 13.0, tvOS 13.0, *)
@available(OSX, unavailable)
@available(watchOS, unavailable)
public struct AnimatedImage : SwiftUI.UIViewRepresentable {
  public let uiImage: UIKit.UIImage
  public let aspectRatio: SwiftUI.ContentMode
  public init(uiImage: UIKit.UIImage, aspectRatio: SwiftUI.ContentMode = .fill)
  public func makeUIView(context: SwiftUI.UIViewRepresentableContext<URLImage.AnimatedImage>) -> UIKit.UIView
  public func updateUIView(_ uiView: UIKit.UIView, context: SwiftUI.UIViewRepresentableContext<URLImage.AnimatedImage>)
  public typealias UIViewType = UIKit.UIView
  public typealias Coordinator = Swift.Void
  public typealias Body = Swift.Never
}
@available(iOS 13.0, tvOS 13.0, OSX 10.15, watchOS 6.0, *)
public struct CircleActivityView : SwiftUI.View {
  public init()
  public func stroke(lineWidth: CoreGraphics.CGFloat = 1) -> URLImage.CircleActivityView
  public var animation: SwiftUI.Animation {
    get
  }
  public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s8URLImage18CircleActivityViewV4bodyQrvp", 0) 🦸
}
@available(iOS 13.0, tvOS 13.0, OSX 10.15, watchOS 6.0, *)
public struct CircleProgressView : SwiftUI.View {
  public init(_ progress: Swift.Float)
  public var progress: Swift.Float
  public func stroke(lineWidth: CoreGraphics.CGFloat = 1) -> URLImage.CircleProgressView
  public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s8URLImage18CircleProgressViewV4bodyQrvp", 0) 🦸
}
public struct CoreImageFilterProcessor : URLImage.ImageProcessing {
  public let name: Swift.String
  public let parameters: [Swift.String : Any]
  public let context: CoreImage.CIContext
  public init(name: Swift.String, parameters: [Swift.String : Any] = [:], context: CoreImage.CIContext = CIContext())
  public func process(_ input: CoreGraphics.CGImage) -> CoreGraphics.CGImage
}
@available(iOS 13.0, tvOS 13.0, OSX 10.15, watchOS 6.0, *)
final public class DownloadProgressWrapper : Combine.ObservableObject {
  @Combine.Published @_projectedValueProperty($progress) final public var progress: Swift.Float? {
    get
    set
    _modify
  }
  final public var $progress: Combine.Published<Swift.Float?>.Publisher {
    get
  }
  public init(progress: Swift.Float? = nil)
  @objc deinit
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
}
public protocol ImageProcessing {
  func process(_ input: CoreGraphics.CGImage) -> CoreGraphics.CGImage
}
public struct ImageProcessorClosure : URLImage.ImageProcessing {
  public let closure: (CoreGraphics.CGImage) -> CoreGraphics.CGImage
  public init(closure: @escaping (CoreGraphics.CGImage) -> CoreGraphics.CGImage)
  public func process(_ input: CoreGraphics.CGImage) -> CoreGraphics.CGImage
}
@available(iOS 13.0, tvOS 13.0, OSX 10.15, watchOS 6.0, *)
public protocol ImageProxy {
  var cgImage: CoreGraphics.CGImage { get }
  var uiImage: UIKit.UIImage { get }
  var isAnimated: Swift.Bool { get }
}
@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(OSX, unavailable)
extension ImageProxy {
  public var image: SwiftUI.Image {
    get
  }
}
@available(iOS 13.0, tvOS 13.0, OSX 10.15, watchOS 6.0, *)
public struct ProgressView<Content> : SwiftUI.View where Content : SwiftUI.View {
  public init(_ downloadProgressWrapper: URLImage.DownloadProgressWrapper, content: @escaping (Swift.Float) -> Content)
  @SwiftUI.ObservedObject @_projectedValueProperty($downloadProgressWrapper) public var downloadProgressWrapper: URLImage.DownloadProgressWrapper {
    get
    set
    _modify
  }
  public var $downloadProgressWrapper: SwiftUI.ObservedObject<URLImage.DownloadProgressWrapper>.Wrapper {
    get
  }
  public var content: (Swift.Float) -> Content
  public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s8URLImage12ProgressViewV4bodyQrvp", 0) 🦸<Content>
}
extension Resize {
  public init(size: CoreGraphics.CGSize, scale: CoreGraphics.CGFloat)
}
public struct Resize : URLImage.ImageProcessing {
  public let size: CoreGraphics.CGSize
  public let scale: CoreGraphics.CGFloat
  public func process(_ input: CoreGraphics.CGImage) -> CoreGraphics.CGImage
}
@available(iOS 13.0, tvOS 13.0, OSX 10.15, watchOS 6.0, *)
public struct URLImage<Content, Placeholder> : SwiftUI.View where Content : SwiftUI.View, Placeholder : SwiftUI.View {
  public init(_ url: Foundation.URL, delay: Foundation.TimeInterval = 0.0, incremental: Swift.Bool = false, animated: Swift.Bool = false, expireAfter expiryDate: Foundation.Date? = nil, processors: [URLImage.ImageProcessing]? = nil, placeholder: @escaping (URLImage.DownloadProgressWrapper) -> Placeholder, content: @escaping (URLImage.ImageProxy) -> Content)
  public init(_ urlRequest: Foundation.URLRequest, delay: Foundation.TimeInterval = 0.0, incremental: Swift.Bool = false, animated: Swift.Bool = false, expireAfter expiryDate: Foundation.Date? = nil, processors: [URLImage.ImageProcessing]? = nil, placeholder: @escaping (URLImage.DownloadProgressWrapper) -> Placeholder, content: @escaping (URLImage.ImageProxy) -> Content)
  public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s8URLImageAAV4bodyQrvp", 0) 🦸<Content, Placeholder>
}
@available(iOS 13.0, tvOS 13.0, OSX 10.15, watchOS 6.0, *)
extension URLImage where Content == SwiftUI.Image {
  public init(_ url: Foundation.URL, delay: Foundation.TimeInterval = 0.0, incremental: Swift.Bool = false, animated: Swift.Bool = false, expireAfter expiryDate: Foundation.Date? = nil, processors: [URLImage.ImageProcessing]? = nil, placeholder: @escaping (URLImage.DownloadProgressWrapper) -> Placeholder, content: @escaping (URLImage.ImageProxy) -> Content = { $0.image })
  public init(_ urlRequest: Foundation.URLRequest, delay: Foundation.TimeInterval = 0.0, incremental: Swift.Bool = false, animated: Swift.Bool = false, expireAfter expiryDate: Foundation.Date? = nil, processors: [URLImage.ImageProcessing]? = nil, placeholder: @escaping (URLImage.DownloadProgressWrapper) -> Placeholder, content: @escaping (URLImage.ImageProxy) -> Content = { $0.image })
}
@available(iOS 13.0, tvOS 13.0, OSX 10.15, watchOS 6.0, *)
extension URLImage where Placeholder == SwiftUI.Image {
  public init(_ url: Foundation.URL, delay: Foundation.TimeInterval = 0.0, incremental: Swift.Bool = false, animated: Swift.Bool = false, expireAfter expiryDate: Foundation.Date? = nil, processors: [URLImage.ImageProcessing]? = nil, placeholder placeholderImage: SwiftUI.Image = {
return Image(systemName: "photo")
    }(), content: @escaping (URLImage.ImageProxy) -> Content)
  public init(_ urlRequest: Foundation.URLRequest, delay: Foundation.TimeInterval = 0.0, incremental: Swift.Bool = false, animated: Swift.Bool = false, expireAfter expiryDate: Foundation.Date? = nil, processors: [URLImage.ImageProcessing]? = nil, placeholder placeholderImage: SwiftUI.Image = {
return Image(systemName: "photo")
    }(), content: @escaping (URLImage.ImageProxy) -> Content)
}
@available(iOS 13.0, tvOS 13.0, OSX 10.15, watchOS 6.0, *)
public protocol URLImageServiceType {
  var services: URLImage.Services { get }
  var defaultExpiryTime: Foundation.TimeInterval { get }
  func setDefaultExpiryTime(_ defaultExpiryTime: Foundation.TimeInterval)
  func resetFileCache()
  func cleanFileCache()
  func removeCachedImage(with url: Foundation.URL)
}
@_hasMissingDesignatedInitializers @available(iOS 13.0, tvOS 13.0, OSX 10.15, watchOS 6.0, *)
final public class Services {
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 13.0, tvOS 13.0, OSX 10.15, watchOS 6.0, *)
final public class URLImageService : URLImage.URLImageServiceType {
  public static let shared: URLImage.URLImageServiceType
  final public let services: URLImage.Services
  final public var defaultExpiryTime: Foundation.TimeInterval {
    get
  }
  final public func setDefaultExpiryTime(_ defaultExpiryTime: Foundation.TimeInterval)
  final public func resetFileCache()
  final public func cleanFileCache()
  final public func removeCachedImage(with url: Foundation.URL)
  @objc deinit
}
